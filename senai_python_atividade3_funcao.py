# -*- coding: utf-8 -*-
"""SENAI-Python-Atividade3-FUNCAO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15M4ql2OrdP0w1t4LgYYtfY4tT4lr0bSj
"""

def saudacao(nome):
  print('Ola' , nome)

nome = input('Entre com um nome: ')

saudacao(nome)

"""Crie a funcao alterna(n) que imprime a sequencia cresente de numeros naturais com mudan;a de sinal alternadamente ate n."""

def alterna(n):
  multiplicador = 1
  result = 0
  for i in range(1, n + 1):
    result = i * multiplicador
    print(result, end=' ')
    multiplicador *= -1
  print()
alterna(5)
alterna(9)
alterna(12)

def area_triangulo(base, altura):
  area = base * altura / 2
  return area

base1 = 2
altura1 = 5

base2 = 4
altura2 = 5

print('Area do triangulo 1: ', area_triangulo(base1, altura1) , 'cm*cm')
print('Area do triangulo 2: ', area_triangulo(base2, altura2) , 'cm*cm')

def area_retangulo(a, b):
  perimetro = (2 * a) + (2 * b)
  return perimetro

a = 2
b = 3

print('Area do triangulo 1: ', area_retangulo(a, b) , 'cm')

def saudacao(nome , mensagem):
  print('Ola' , nome , '\b!' , mensagem)

saudacao('Joao' , 'Como vc esta?')

saudacao(mensagem = 'Tudo bem?' , nome = 'Maria')

def saudacao(nome , mensagem = 'Bom dia!'):
  print('Ola' , nome , '\b!' , mensagem)

saudacao('Ana')

saudacao('Pedro' , 'Boa tarde!')

def quadrado(numero):
  return numero ** 2

resultado = quadrado(4)
print('O quadrado de 4 e: ', resultado)

def calcular_valores(numero):
  triplo = numero * 3
  quadruplo = numero * 4
  quinta_potencia = numero ** 5
  return triplo, quadruplo, quinta_potencia

resultado = calcular_valores(2)
print(resultado)

triplo, quadruplo, quinta_potencia = calcular_valores(3)
print(triplo)
print(quadruplo)
print(quinta_potencia)

def soma_pn(valores):
  soma_p = 0
  soma_n = 0

  for n in valores:
    if n > 0:
      soma_p += n
    else:
      soma_n += n

  return soma_p, soma_n

valores = [2, -1, 3, -4]
soma_p, soma_n = soma_pn(valores)
print(f'soma dos positivos = {soma_p}\nsoma dos negativos = {soma_n}')

valores = [2 , -1 , 3 , -4]

def somas(valores):
  return sum(valores), somas([x**2 for x in valores])

somas = ([2 , -1 , 3 , -4])

# Calculadora em Python #
res = 0

def soma(a, b):
  return a + b
def subtracao(a, b):
  return a - b
def multiplicacao(a, b):
  return a * b
def divisao(a, b):
  return a / b if b != 0 else None
def potenciacao(a, b):
  return a ** b

def exibir_menu():
  print("Escolha a operação:")
  print("1. Soma")
  print("2. Subtração")
  print("3. Multiplicação")
  print("4. Divisão")
  print("5. Potenciação")

def calculadora():
  exibir_menu()
  opcao = input("Digite o número da operação desejada: ")

  a = float(input("Digite o primeiro número: "))
  b = float(input("Digite o segundo número: "))

  if opcao == '1':
    res = soma(a,b)

  elif opcao == '2':
    res = subtracao(a,b)

  elif opcao == '3':
    res = multiplicacao(a,b)

  elif opcao == '4':
    res = divisao(a,b)

  elif opcao == '5':
    res = potenciacao(a,b)

  else:
    print("Opção inválida! Por favor, escolha uma opção válida.")

  print(f'Resposta = {res}')
calculadora()

cpf = input('Entre com o CPF: ')
cpfn = [int(d) for d in cpf]
cpfn

#95559167053

def validar_digito_verificador_1(digitos):
# Implemente a lógica para validar o dígito verificador 1
  soma_prod = 0
  for n in range(9):
    soma_prod += (digitos[n] * (10 - n))
  #print(f'soma_prod = {soma_prod}')
  d1 = ((soma_prod * 10) % 11) % 10
  #print(d1)
  return d1 == digitos[-2]

def validar_digito_verificador_2(digitos):
# Implemente a lógica para validar o dígito verificador 2
  soma_prod = 0
  for n in range(10):
    soma_prod += (digitos[n] * (11 - n))
  #print(f'soma_prod = {soma_prod}')
  d2 = ((soma_prod * 10) % 11) % 10
  #print(d2)
  return d2 == digitos[-1]


def validar_cpf(cpf):
# Implemente a lógica para validar o CPF
  #print(f'cpf = {cpf}')
  cpfn = [int(d) for d in cpf if d.isdigit()]
  #print(f'cpf = {cpf}')
  if len(set(cpfn)) == 1:
    return False

  v1 = validar_digito_verificador_1(cpfn)
  if v1 == False:
    return False

  v2 = validar_digito_verificador_2(cpfn)
  if v2 == True:
    return True
  else:
    return False


# Função principal para solicitar o CPF ao usuário e validar
def main():
  cpf = input("Digite o CPF (apenas números): ")
  if validar_cpf(cpf):
    print("CPF válido!")
  else:
    print("CPF inválido!")
# Chamando a função principal main()
main()

def gerar_digito_verificador_1(digitos):
  soma_prod = 0
  for n in range(9):
    soma_prod += (digitos[n] * (10 - n))
  d1 = ((soma_prod * 10) % 11) % 10
  return d1

def gerar_digito_verificador_2(digitos):
  soma_prod = 0
  for n in range(9):
   soma_prod += (digitos[n] * (11 - n))
  d2 = ((soma_prod * 10) % 11) % 10
  return d2

def gerar_cpf(cpf1):
  cpf = [int(d) for d in cpf1]
  d1 = gerar_digito_verificador_1(cpf)
  cpf.append(d1)
  d2 = gerar_digito_verificador_2(cpf)
  cpf.append(d2)
  return (str(cpf[0]) + str(cpf[1]) + str(cpf[2]) + '.' +
          str(cpf[3]) + str(cpf[4]) + str(cpf[5]) + '.' +
          str(cpf[6]) + str(cpf[7]) + str(cpf[8]) + '-' + str(d1) + str(d2))

def main():
  cpf9 = input("Digite os primeiros 9 digitos do CPF a ser gerado (apenas números): ")
  cpf = gerar_cpf(cpf9)
  print(f'CPF = {cpf}')

main()

PI = 3.1415

def area_circulo(raio):
  return PI * raio ** 2
print('A area do circulo unitario vale' , area_circulo(1))


def area_circulo(raio):
  PI = 3
  return PI * raio ** 2
print('A area do circulo unitario vale' , area_circulo(1))
print('PI = ' , PI)

def externa():
  print('Esta funcao e externa')
  def interna():
    print('Esta funcao e interna')

  interna()
externa()

def externa():
  print('Esta funcao e externa')

  def interna():
    print('Esta funcao e interna')
    print(f'Valor de PI = {PI}')
  PI = 3.1415

  interna()

externa()

def minha_funcao():
  print('Ola, Mundo!')

outra_funcao = minha_funcao
outra_funcao()

def chamada(funcao):
  funcao()

chamada(minha_funcao)

def criar_multiplicador(n):
  def multiplicar(x):
    return x * n
  return multiplicar

multiplicar_por_2 = criar_multiplicador(2)

multiplicar_por_3 = criar_multiplicador(3)

print(multiplicar_por_2(5))
print(multiplicar_por_3(5))

def calculadora(operador):
  def operacao(a, b):
    return eval(f'{a} {operador} {b}')
  return operacao

soma = calculadora('+')
print(soma(5, 3))

subtracao = calculadora('-')
print(subtracao (10, 4))

multiplicacao = calculadora('*')
print(multiplicacao(6, 7))

divisao = calculadora('/')
print(divisao(20, 4))

fatorialDesejado = int(input('Digite o numero que deseja ter o fatorial: '))

def fatorial(n):
  if n == 1:
    return 1
  return n * fatorial(n - 1)

resultado = fatorial(fatorialDesejado)
print(f'O fatorial de {fatorialDesejado} e: {resultado}')

def potencia(a, b):
  if b == 0:
    return 1
  return a * potencia(a, b-1)

potencia(5 , 3)

quadrado = lambda x: x ** 2

print(quadrado(3))

c2f = lambda c: (c * 8/5) + 32

print(c2f(0))

(lambda c: (c * 8/5) + 32)(0)

max = lambda a, b: a if a > b else b

max(1,2)

def decorador(funcao):
  def wrapper():
    print('Antes da chamada da funcao')
    funcao()
    print('Depois da chamada da funcao')
  return wrapper

@decorador
def minha_funcao():
  print('Funcao decorada')

minha_funcao()

def estima_pi(n):
  for _ in range(n)
    n

def raiz(N):
  if N == 0 or N == 1:
    return N

  if N < 0:
    N = -N

  x, n = 1 , 0
  while abs(x * x - N) > 1e-9:
    n += 1
    x = 0.5 * (x + N / x)
  return x

N = 7
raiz(N) * raiz(N)

def pitagoras(a, b):

  """
  Calcula a hipotenusa
  de triangulo retangulo
  de catetos a e b
  """

  return raiz(a*a + b*b)

pitagoras(3, 4)

def equagrau2(a , b , c):

  """
  Resolve:
  a * x**2 + b * x + c = 0
  """

  delta = (b**2 - 4 * a * c)
  if delta < 0:
    print(f'Delta ({delta}) e menor que 0!')
    return None

  r_delta = raiz(delta)
  x1 = (-b - r_delta) / (2 * a)
  x2 = (-b + r_delta) / (2 * a)
  return x1, x2

a, b, c = 1, -5, 6

equagrau2(a , b , c)

a, b, c = 10, 1, 1

equagrau2(a , b , c)

def soma_r(nR):
  if nR == 1:
    return 1
  return nR + soma_r(nR-1)

def soma_i(nI):
    soma = 0
    for nI in range(1, nI+1):
      soma += nI
    return soma

soma_r(100)

soma_i(100)

def f(n):
  if n == 0 or n == 1:
    return n
  return f(n-1) + f(n-2)

f(4)

[f(n) for n in range(1 , 10)]

[(-1)**x  for x in range(n)]

def estima_pi(n):
  return 4*sum([1/((2 * x+1) * (-1)**x)  for x in range(n)])

estima_pi(1)

import numpy
numpy.pi